use core::ops::Deref;

use crate::syscall_common::*;
use crate::{
    kprintln, scheduler,
    x86::{interrupt, mmu},
};

pub fn syscall(frame: &mut interrupt::InterruptFrame) {
    // al == syscall number
    let matched = match_syscall(frame, SyscallNo::Exit, |frame, _: ()| exit(frame))
        || match_syscall(frame, SyscallNo::YieldCpu, |frame, _: ()| yield_cpu(frame))
        || match_syscall(frame, SyscallNo::Puts, |frame, s: &str| puts(frame));

    assert!(matched, "invalid syscall");
}

pub trait Arg {
    unsafe fn validate(arg: *const Self) -> bool;
}
impl Arg for () {
    unsafe fn validate(arg: *const Self) -> bool {
        true
    }
}

fn validate_range(start: usize, len: usize, write: bool) -> bool {
    let mmu = mmu::MMU.take().unwrap();
    let mmu = mmu.deref();

    mmu.mapper.validate_range(
        &mmu.allocator,
        start,
        len,
        mmu::mmap::MappingFlags::new().with_writable(write),
    )
}
impl<T: Arg + core::ptr::Thin> Arg for &T {
    unsafe fn validate(arg: *const Self) -> bool {
        // make sure the pointer is valid and properly aligned
        let ptr = *(arg as *const *const T);

        validate_range(ptr as usize, core::mem::size_of_val_raw(ptr), false)
            && ptr.align_offset(core::mem::align_of_val_raw(ptr)) == 0
    }
}
impl<T: Arg + core::ptr::Thin> Arg for &mut T {
    unsafe fn validate(arg: *const Self) -> bool {
        todo!()
    }
}
impl<T: Arg> Arg for &[T] {
    unsafe fn validate(arg: *const Self) -> bool {
        todo!()
    }
}
impl<T: Arg> Arg for &mut [T] {
    unsafe fn validate(arg: *const Self) -> bool {
        todo!()
    }
}

impl Arg for u8 {
    unsafe fn validate(arg: *const Self) -> bool {
        true
    }
}
impl Arg for &str {
    unsafe fn validate(arg: *const Self) -> bool {
        let byte_slice = arg.cast::<&[u8]>();
        <&[u8]>::validate(byte_slice) && core::str::from_utf8(*byte_slice).is_ok()
    }
}

fn match_syscall<A: Arg, T: Arg>(
    frame: &mut interrupt::InterruptFrame,
    num: SyscallNo,
    func: fn(&mut interrupt::InterruptFrame, A) -> T,
) -> bool {
    if frame.eax as u8 == num as u8 {
        assert!(A::validate(frame.esi as *mut A), "invalid syscall arg");
        unsafe {
            func(frame, *(frame.esi as *mut A));
        }
        true
    } else {
        false
    }
}

fn exit(frame: &mut interrupt::InterruptFrame) {
    let mut scheduler = scheduler::SCHEDULER.take().unwrap();
    let scheduler = scheduler.as_mut().unwrap();
    kprintln!("Process {} exited.", scheduler.current_pid());
    scheduler.kill_current_process(frame);
}

fn yield_cpu(frame: &mut interrupt::InterruptFrame) {
    let mut scheduler = scheduler::SCHEDULER.take().unwrap();
    let scheduler = scheduler.as_mut().unwrap();

    scheduler.schedule(frame);
}

fn puts(frame: &mut interrupt::InterruptFrame) {
    let (vaddr, size) = (frame.eax, frame.ebx);

    let mmu = mmu::MMU.take().unwrap();
    let mmu = &*mmu;

    let mut scheduler = scheduler::SCHEDULER.take().unwrap();
    let scheduler = scheduler.as_mut().unwrap();

    let pid = scheduler.current_pid();

    if !mmu.mapper.validate_range(
        &mmu.allocator,
        vaddr,
        size,
        mmu::mmap::MappingFlags::new().with_user_accessible(true),
    ) {
        let mut scheduler = scheduler::SCHEDULER.take().unwrap();
        let scheduler = scheduler.as_mut().unwrap();

        kprintln!("Killing process {} (invalid memory access)", pid);
        scheduler.kill_current_process(frame);
    }

    let buf = unsafe { core::slice::from_raw_parts(vaddr as *const _, size) };
    match core::str::from_utf8(buf) {
        Ok(text) => kprintln!("[{}]: {}", pid, text),
        Err(err) => kprintln!("[{}]: <invalid UTF-8: {:?}>", pid, err),
    }
}
